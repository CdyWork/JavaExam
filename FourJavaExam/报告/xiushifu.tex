\documentclass{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings} % 用于代码框
\usepackage{xcolor} % 用于代码高亮   \title{Java中各类修饰符的使用总结}
\author{浮生若梦}
\date{2025-10-21}   \begin{document}
\maketitle   \section{类修饰符}
\subsection{访问修饰符}
\textbf{公共类修饰符 public}：Java语言中类的访问控制符只有public即公共的。每个Java程序的有且只有一个类是public，它被称为\textbf{主类}。其他外部类无访问控制修饰符，具有包访问性。注意：一个类的内部类可以被其他访问控制修饰符protected、缺省默认(default、friendly)、private修饰，相当于类的成员。   \subsection{非访问控制修饰符}
\textbf{抽象类}：修饰符abstract。用abstract修饰符修饰的类，被称为抽象类。抽象类不能被实例化，只能被继承。
\textbf{最终类}：修饰符final。当一个类不能被继承时可用修饰符final修饰为最终类。被定义为final的类通常是一些有固定作用、用来完成某种标准功能的类。
\textbf{类缺省访问控制符}：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时，这个类只能被同一个包中的类访问或引用。这一访问特性又称为包访问性。   \section{方法修饰符}
\subsection{访问控制修饰符}
公共访问控制符public、保护访问控制符protected、缺省默认访问控制符、私有访问控制符private。   \subsection{非访问控制修饰符}
\textbf{抽象方法控制符 abstract}：abstract修饰的方法称为抽象方法。抽象方法仅有方法头，没有方法体和具体实现。
\textbf{静态方法控制符 static}：用修饰符static修饰的方法称为静态方法。静态方法是属于整个类的类方法；而不使用static修饰的方法是属于某个具体类对象的方法。由于static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即static方法只能处理static的域。
\textbf{最终方法控制符 final}：用修饰符final修饰的方法称为最终方法。最终方法是功能和内部语句不能更改的方法，即最终方法不能被重写覆盖。final固定了方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性。所有被private修饰符限定为私有的方法，以及所有包含在final类(最终类)中的方法，都被认为是最终方法。
\textbf{本地方法控制符 native}：用修饰符native修饰的方法称为本地方法。为了提高程序的运行速度，需要用其它的高级语言书写程序的方法体，那么该方法可定义为本地方法用修饰符native来修饰。
\textbf{同步方法方法符 synchronized}：该修饰符主要用于多线程程序中的协调和同步。   \section{变量修饰符}
\subsection{访问控制修饰符}
公共访问控制符public、保护访问控制符protected、缺省默认访问控制符、私有访问控制符private。   \subsection{非访问控制修饰符}
\textbf{静态域修饰符 static}：用static修饰的成员变量仅属于类的变量，而不属于任何一个具体的对象。静态成员变量的值是保存在类的内存区域的公共存储单元，而不是保存在某一个对象的内存区间。该类的任一对象访问它时取到的都是相同的数据；该类的任一对象修改它时,也都是对同一个内存单元进行操作。
\textbf{最终域修饰符 final}：最终域修饰符final是用来定义常量的。一个类的域(成员变量)如果被修饰符final说明，则它的取值在程序的整个执行过程中都是不变的。
\textbf{易失(共享)域修饰符 volatile}：易失(共享)域修饰符volatile用来说明这个成员变量可能被几个线程所控制和修改。也就是说在程序运行过程中，这个成员变量有可能被其它的程序影响或改变它的取值。通常volatile用来修饰接受外部输入的域。
\textbf{暂时性域修饰符 transient}：暂时性域修饰符transient用来定义一个暂时性变量。其特点是：用修饰符transient限定的暂时性变量，将指定Java虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。   \section{访问控制修饰符总结}
\begin{table}[h]
\centering
\begin{tabular}{@{}cccccc@{}}
\toprule
\textbf{访问级别} & \textbf{访问控制修饰符} & \textbf{同类} & \textbf{同包} & \textbf{子类(不同包)} & \textbf{不同包(其他类)} \
\midrule
公共 & public & 允许 & 允许 & 允许 & 允许 \
受保护 & protected & 允许 & 允许 & 允许 & 不允许 \
默认 & 缺省修饰符 & 允许 & 允许 & 不允许 & 不允许 \
私有 & private & 允许 & 不允许 & 不允许 & 不允许 \
\bottomrule
\end{tabular}
\end{table}
注意：protected修饰的属性或方法，允许不同包的子类通过继承访问父类中的protected属性或方法，而不是直接通过父类实例访问protected属性或方法。   \section{代码示例}
\begin{lstlisting}[language=Java, backgroundcolor=\color{lightgray}, frame=single]
public class Animal {
protected String name; // 受保护的成员变量，可以在同一个包内或子类中访问
public int age; // 公共成员变量，可以在任何地方访问 
public void print() {
    // 不能通过父类实例直接访问受保护的成员变量
    // Animal a = new Animal(); 
    // System.out.println(a.name); // 错误：不允许直接访问受保护的成员变量
    System.out.println(age); // 允许，因为age是public的

    // 通过继承访问受保护的成员变量
    System.out.println(name); // 允许，因为Cat是Animal的子类
    System.out.println(this.age); // 允许，使用this关键字访问
}
}   // 不同包的子类
public class Cat extends Animal {
public void printCatInfo() {
// 不能通过父类实例直接访问受保护的成员变量
// Animal a = new Animal();
// System.out.println(a.name); // 错误：不允许直接访问受保护的成员变量
System.out.println(age); // 允许，因为age是public的 
    // 通过继承访问受保护的成员变量
    System.out.println(name); // 允许，因为Cat是Animal的子类
    System.out.println(this.age); // 允许，使用this关键字访问
}
}
\end{lstlisting}
\end{document}